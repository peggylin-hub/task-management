# MAUI Task Management Application

## Project Overview
This is a cross-platform task management application built with .NET MAUI that allows users to manage tasks across desktop (Windows/macOS), mobile (Android/iOS), and web platforms. The application features user authentication, real-time synchronization, and offline capability with automatic sync when connectivity is restored.

## Application Features
- User Authentication: Secure login/logout with token-based authentication
- Task Management: Create, edit, delete, and organize tasks
- Real-time Sync: Changes sync automatically across all platforms (desktop, web, mobile)
- Offline Support: Work offline with automatic sync when connection is restored
- Cross-platform: Single codebase for desktop and mobile with web integration

## Technology Stack
- Framework: .NET MAUI (.NET 8+)
- Language: C#
- UI Framework: XAML with MAUI Controls
- Architecture Pattern: MVVM (Model-View-ViewModel)
- Platforms: Android, iOS, Windows, macOS
- Backend Integration: RESTful API communication
- Authentication: JWT/OAuth token-based authentication
- Data Sync: Real-time synchronization with web application
- Local Storage: SQLite for offline data persistence
- Networking: HTTP client with retry policies and offline handling

## Project Structure
```
├── Platforms/              # Platform-specific code
│   ├── Android/            # Android-specific implementations
│   ├── iOS/               # iOS-specific implementations
│   ├── Windows/           # Windows-specific implementations
│   └── MacCatalyst/       # macOS-specific implementations
├── Views/                 # XAML pages and user controls
│   ├── Auth/              # Login/Registration pages
│   ├── Tasks/             # Task management pages
│   ├── Settings/          # User settings and preferences
│   └── Shared/            # Reusable controls and templates
├── ViewModels/            # ViewModel classes (MVVM pattern)
│   ├── Auth/              # Authentication ViewModels
│   ├── Tasks/             # Task management ViewModels
│   └── Base/              # Base ViewModels and common functionality
├── Models/                # Data models and entities
│   ├── DTOs/              # Data Transfer Objects for API communication
│   ├── Entities/          # Local database entities
│   └── Responses/         # API response models
├── Services/              # Business logic and data services
│   ├── Auth/              # Authentication services
│   ├── Tasks/             # Task management services
│   ├── Sync/              # Data synchronization services
│   ├── Storage/           # Local data storage services
│   └── Network/           # API communication services
├── Data/                  # Database context and repositories
│   ├── Context/           # SQLite database context
│   └── Repositories/      # Data access layer
├── Helpers/               # Utility classes and extensions
│   ├── Converters/        # XAML value converters
│   ├── Constants/         # Application constants
│   └── Extensions/        # Extension methods
├── Resources/             # Images, fonts, styles, and other assets
├── App.xaml              # Application-level resources and configuration
└── MauiProgram.cs        # Application startup and dependency injection
```

## Development Guidelines

### Code Style & Conventions
- Follow C# naming conventions (PascalCase for public members, camelCase for private fields)
- Use meaningful names for variables, methods, and classes
- Implement proper async/await patterns for asynchronous operations
- Use dependency injection for service management
- Follow MVVM pattern strictly - no code-behind logic in views

### XAML Guidelines
- Use data binding instead of direct UI manipulation
- Implement proper resource management with StaticResource and DynamicResource
- Use consistent spacing and indentation (4 spaces)
- Group related properties together in XAML elements
- Use meaningful x:Name values when element access is needed

### Authentication & Security
- Implement secure token storage using platform-specific secure storage
- Use JWT tokens with automatic refresh mechanisms
- Implement proper logout with token cleanup
- Handle authentication failures and expired tokens gracefully

### Data Synchronization Patterns
- Repository Pattern: Abstract data access for both local and remote sources
- Unit of Work: Manage transactions across multiple repositories
- Offline-First: Local SQLite database as primary data source
- Conflict Resolution: Last-writer-wins with user notification for conflicts
- Background Sync: Automatic sync when app is backgrounded/foregrounded
- Real-time Updates: SignalR for live updates from web application
- Optimistic Updates: Update UI immediately, rollback on server failure
- Retry Logic: Exponential backoff for failed sync operations

## Key Dependencies & NuGet Packages
- Microsoft.Extensions.Logging - Logging framework
- CommunityToolkit.Mvvm - MVVM helpers and commands
- CommunityToolkit.Maui - Additional MAUI controls and extensions
- System.Text.Json - JSON serialization for API communication
- Microsoft.Extensions.Http - HTTP client factory with retry policies
- sqlite-net-pcl - SQLite database for local storage
- Microsoft.EntityFrameworkCore.Sqlite - EF Core for database operations
- Polly - Resilience and retry policies for network calls
- Microsoft.Authentication.WebAssembly.Msal - Authentication library
- Refit - Type-safe REST API client
- Microsoft.AspNetCore.SignalR.Client - Real-time communication for sync updates
- Microsoft.Maui.Essentials - Cross-platform APIs for device features

## Common Patterns to Implement

### Authentication Flow
1. Implement login/logout ViewModels with secure token storage
2. Use dependency injection for authentication services
3. Implement automatic token refresh mechanism
4. Handle authentication state across app lifecycle
5. Secure API calls with bearer token authentication

### Task Management Operations
1. Create task CRUD operations with local and remote persistence
2. Implement offline-first approach with conflict resolution
3. Use repository pattern for data access abstraction
4. Implement real-time updates via SignalR connections
5. Handle optimistic UI updates with rollback on failure

### Data Synchronization
1. Implement background sync service for automatic updates
2. Use last-modified timestamps for conflict resolution
3. Queue local changes when offline for later sync
4. Handle partial sync failures gracefully
5. Notify users of sync status and conflicts

## Error Handling & User Experience
- Implement global exception handling with user-friendly messages
- Show sync status indicators in UI (syncing, offline, error states)
- Provide manual sync option for user control
- Handle network connectivity changes gracefully
- Use loading indicators during sync operations
- Implement proper offline indicators in UI

## Platform-Specific Considerations

### Android
- Target API level 33+ (Android 13)
- Configure proper permissions in Platforms/Android/AndroidManifest.xml
- Handle Android back button navigation
- Implement proper activity lifecycle management
- Handle network security configuration

### iOS
- Target iOS 14.0+
- Configure Info.plist for required permissions
- Handle iOS-specific navigation patterns
- Implement proper memory management for iOS
- Configure App Transport Security settings

### Windows
- Target Windows 10 version 1809+
- Configure proper app manifest
- Handle Windows-specific input methods
- Implement proper window management
- Configure proper certificates for deployment

## Testing Strategy
- Unit Tests: ViewModels, Services, and Repository classes
- Integration Tests: API communication and database operations
- Sync Testing: Multi-device synchronization scenarios
- Authentication Tests: Login/logout flows and token management
- Offline Tests: Functionality without network connectivity
- UI Tests: Cross-platform user interface behavior
- Performance Tests: Sync performance with large datasets

## Cursor AI Guidance Rules

### When suggesting code:
- Always consider user authentication state in suggestions
- Recommend patterns that work with real-time synchronization
- Suggest solutions that work offline with eventual consistency
- Consider how changes will sync between desktop, web, and mobile
- Prioritize task CRUD operations and management features
- Always recommend secure storage and transmission of user data
- Consider network efficiency and local storage optimization
- Suggest UI patterns that clearly communicate sync status and conflicts
- Recommend robust error handling for network and sync failures
- Consider how the app works across different device types and screen sizes

### Code Generation Priorities:
1. Authentication-first development approach
2. Sync-aware code patterns
3. Offline-first design principles
4. Cross-platform compatibility
5. MVVM architecture compliance
6. Proper dependency injection usage
7. Secure data handling
8. Performance optimization
9. User experience considerations
10. Error resilience

### Always include when generating code:
- Proper using statements for MAUI and related packages
- Async/await patterns for network operations
- Error handling with try-catch blocks
- Logging statements for debugging
- Comments explaining complex synchronization logic
- Data validation and sanitization
- Proper disposal of resources
- Thread-safe operations for shared data

### Avoid in code suggestions:
- Synchronous network calls
- Hardcoded API endpoints or credentials
- Direct UI manipulation in ViewModels
- Platform-specific code in shared logic
- Blocking operations on UI thread
- Unhandled exceptions
- Memory leaks in event handlers
- Insecure data storage
- Complex nested callbacks
- Tight coupling between components